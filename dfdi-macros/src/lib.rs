#![forbid(unsafe_code)]

mod derive_service;

use proc_macro::TokenStream;
use syn::{parse_macro_input, DeriveInput, Error};

/// Create an implementation of [`Service`] on a `'static` version of the original type.
///
/// More specifically, the derive macro follows these steps:
/// - Replace all the lifetimes on the type with `'static` and implement `Service` on the new type
/// - Set `Output<'cx>` to the original type but with all the lifetimes replaced by `'cx`
/// - Set `Error` to the specified error type (or [`Infallible`](std::convert::Infallible) if no
///   error type is specified)
///
/// ```
/// # use dfdi::Service;
/// #[derive(Service)]
/// struct Ref<'a, T>(&'a T);
///
/// // Code generated by the derive
///
/// // impl<T> Service for Ref<'static, T> {
/// //    type Error = Infallible;
/// //    type Output<'cx> = Ref<'cx, T>;
/// // }
/// ```
///
/// To specify an error type, annotate the type you are deriving `Service` on with `#[service(error
/// = MyErrorType)]`
/// ```
/// # use dfdi::Service;
/// struct MyError;
///
/// #[derive(Service)]
/// #[service(error = MyError)]
/// struct MayFail { }
///
/// // Code generated by the derive
///
/// // impl Service for MayFail> {
/// //    type Error = MyError;
/// //    type Output<'cx> = MayFail;
/// // }
/// ```
///
#[proc_macro_derive(Service, attributes(service))]
pub fn derive_service(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    derive_service::derive_service(input)
        .unwrap_or_else(Error::into_compile_error)
        .into()
}
