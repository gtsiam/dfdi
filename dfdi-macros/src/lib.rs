#![forbid(unsafe_code)]

mod derive_service;

use proc_macro::TokenStream;
use syn::{parse_macro_input, DeriveInput, Error};

/// Create an implementation of [`Service`] on a `'static` version of the original type.
///
/// More specifically, the derive macro follows these steps:
/// - Replace all the lifetimes on the type with `'static` and implement `Service` on the new type
/// - Set `Output<'cx>` to the original type but with all the lifetimes replaced by `'cx`
///
/// ```
/// # use dfdi::Service;
/// #[derive(Service)]
/// struct Ref<'a, T>(&'a T);
///
/// // Code generated by the derive
///
/// // impl<T> Service for Ref<'static, T> {
/// //    type Output<'cx> = Ref<'cx, T>;
/// // }
/// ```
#[proc_macro_derive(Service, attributes(service))]
pub fn derive_service(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    derive_service::derive_service(input)
        .unwrap_or_else(Error::into_compile_error)
        .into()
}
